syntax = "proto3";

package kv;

service KeyValue {
  rpc Set (SetRequest) returns (SetResponse);
  rpc Get (GetRequest) returns (GetResponse);
  rpc Delete (DeleteRequest) returns (DeleteResponse);
  rpc BatchSet (BatchSetRequest) returns (BatchSetResponse);
  rpc BatchGet (BatchGetRequest) returns (BatchGetResponse);
  rpc BatchDelete (BatchDeleteRequest) returns (BatchDeleteResponse);
  rpc GetMetrics (GetMetricsRequest) returns (GetMetricsResponse);
  // Get the expiration timestamp for a key (0 = no expiration or key not found)
  rpc GetExpireAt (GetExpireAtRequest) returns (GetExpireAtResponse);
  // Compare-and-set: atomically set value if current value matches expected
  rpc CompareAndSet (CompareAndSetRequest) returns (CompareAndSetResponse);
  // Promote follower to leader (stops replication, enables writes)
  rpc PromoteToLeader (PromoteRequest) returns (PromoteResponse);
}

message SetRequest {
  string key = 1;
  string value = 2;
  // TTL in seconds (0 = no expiration)
  uint64 ttl_seconds = 3;
}

message SetResponse {
  bool success = 1;
}

message GetRequest {
  string key = 1;
  // If true, include expire_at in the response
  bool include_expire_at = 2;
}

message GetResponse {
  string value = 1;
  // Unix timestamp when the key expires (0 = no expiration)
  // Only populated when include_expire_at is true in the request
  uint64 expire_at = 2;
}

message DeleteRequest {
  string key = 1;
}

message DeleteResponse {
  bool success = 1;
}

message KeyValuePair {
  string key = 1;
  string value = 2;
}

message BatchSetRequest {
  repeated KeyValuePair items = 1;
}

message BatchSetResponse {
  bool success = 1;
  int32 count = 2;
}

message BatchGetRequest {
  repeated string keys = 1;
}

message BatchGetResponse {
  repeated KeyValuePair items = 1;
}

message BatchDeleteRequest {
  repeated string keys = 1;
}

message BatchDeleteResponse {
  bool success = 1;
  int32 count = 2;
}

message GetMetricsRequest {
}

message GetExpireAtRequest {
  string key = 1;
}

message GetExpireAtResponse {
  // Unix timestamp when the key expires (0 = no expiration, key has no TTL set)
  uint64 expire_at = 1;
  // Whether the key exists
  bool exists = 2;
}

message CompareAndSetRequest {
  string key = 1;
  // Expected current value. If expect_exists is false, this is ignored.
  string expected_value = 2;
  // New value to set if the condition is met
  string new_value = 3;
  // If false, the key must not exist for CAS to succeed
  bool expect_exists = 4;
  // TTL in seconds (0 = no expiration)
  uint64 ttl_seconds = 5;
}

message CompareAndSetResponse {
  // true if the value was updated, false if the condition was not met
  bool success = 1;
  // The actual current value (for debugging/retry). Empty if key doesn't exist.
  string current_value = 2;
}

message PromoteRequest {
  bool enable_replication_service = 1;  // Whether to start replication service for followers
  uint32 replication_port = 2;          // Port for replication service (0 = default: main port + 1)
}

message PromoteResponse {
  bool success = 1;
  string message = 2;
}

message GetMetricsResponse {
  // Operation counts
  uint64 get_count = 1;
  uint64 set_count = 2;
  uint64 delete_count = 3;
  uint64 batch_get_count = 4;
  uint64 batch_set_count = 5;
  uint64 batch_delete_count = 6;

  // SSTable metrics
  uint64 sstable_searches = 10;
  uint64 bloom_filter_hits = 11;
  uint64 bloom_filter_false_positives = 12;
  double bloom_effectiveness = 13;

  // MemTable metrics
  uint64 memtable_flushes = 20;
  uint64 memtable_flush_bytes = 21;

  // Compaction metrics
  uint64 compaction_count = 30;
  uint64 compaction_bytes_read = 31;
  uint64 compaction_bytes_written = 32;

  // Block cache metrics
  uint64 blockcache_entries = 40;
  uint64 blockcache_size_bytes = 41;
  uint64 blockcache_max_size_bytes = 42;
  uint64 blockcache_hits = 43;
  uint64 blockcache_misses = 44;
  uint64 blockcache_evictions = 45;
  double blockcache_hit_ratio = 46;
}