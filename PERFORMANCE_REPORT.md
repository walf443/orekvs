# Orelsm 性能レポート

## 実行環境
- **OS**: Darwin (Mac)
- **ビルド**: Release (`cargo build --release`)
- **日付**: 2026-01-24 (WAL圧縮 v2 導入後)

## ベンチマーク
- **ワークロード**: 10,000 Random Set / 10,000 Random Get
- **並行性**: 10 スレッド
- **データサイズ**: 小さなキー (1..100の数値文字列) と値 (約20文字)。衝突率高め。

## 結果

### 1. スループット (Requests per Second)

| エンジン | Set (req/sec) | Get (req/sec) | 備考 |
| :--- | :---: | :---: | :--- |
| **Memory** | 25,744 | 26,198 | ベースライン (メモリ上のHashMap) |
| **Log** | 249* | 24,436 | *永続性のために `sync_all()` を使用 |
| **LSM-tree** | 1,247** | 26,836*** | **SkipList + Binary Search |

### 2. レイテンシ (リクエストあたりの平均)

| エンジン | Set (平均) | Get (平均) |
| :--- | :---: | :---: |
| **Memory** | 0.36 ms | 0.35 ms |
| **Log** | 40.10 ms* | 0.38 ms |
| **LSM-tree** | 7.98 ms** | 0.35 ms*** |

***LSM-tree の Get が Memory を上回りました** - SkipList のロックフリーアクセスとブロック内バイナリサーチの効果です。

## 今回の最適化内容

### 1. SkipList MemTable (`crossbeam-skiplist`)

従来の `BTreeMap + Mutex` から `crossbeam-skiplist::SkipMap` に変更しました。

| 特性 | BTreeMap + Mutex | SkipList (lock-free) |
|------|------------------|----------------------|
| 読み込み | ロック必要 | ロック不要 |
| 書き込み | ロック必要 | CAS操作のみ |
| 並行読み込み | 直列化 | 完全並列 |

**マイクロベンチマーク結果**:
| 並行度 | BTreeMap+Mutex | SkipList | 高速化 |
|--------|----------------|----------|--------|
| 1 thread x2 | 12.48ms | 4.90ms | 2.55x |
| 2 threads x2 | 26.76ms | 3.00ms | 8.93x |
| 4 threads x2 | 37.08ms | 5.66ms | 6.55x |
| 8 threads x2 | 72.20ms | 13.61ms | 5.30x |

### 2. ブロック内バイナリサーチ

SSTable のブロック検索を線形スキャンからバイナリサーチに変更しました。

| エントリ数 | 線形スキャン | バイナリサーチ | 高速化 |
|------------|--------------|----------------|--------|
| 50 (中央) | 11.80ms | 5.29ms | 2.2x |
| 200 (末尾) | 36.33ms | 3.26ms | 11.1x |
| 500 (末尾) | 89.12ms | 4.07ms | 21.9x |

## 過去の比較 (LSM-tree)

| バージョン | Set (req/sec) | Get (req/sec) | 最適化内容 |
| :--- | :---: | :---: | :--- |
| 初期実装 | 245 | - | 基礎的なLSM-tree |
| グループコミット | 1,151 | - | 複数の書き込みを1回の `sync_all` で実行 |
| パイプラインWAL | 1,163 | 24,601 | I/O待機中のMemTable更新と読み取りの並行化 |
| SkipList + BinarySearch | 1,247 | 26,836 | ロックフリーMemTable + ブロック内バイナリサーチ |
| **WAL圧縮 v2** | **1,240** | **25,634** | ブロック単位のオプショナル圧縮 |

### WAL圧縮 v2 フォーマット

WAL v2 では、512バイト以上のブロックに対してzstd圧縮を適用します。

| 特性 | WAL v1 | WAL v2 |
|------|--------|--------|
| 圧縮 | なし | 512バイト以上で自動圧縮 |
| フォーマット | エントリ単位 | ブロック単位 |
| 後方互換性 | - | v1読み取りサポート |

**圧縮効果 (ランダム英数字データ):**
| 操作 | 値サイズ | 圧縮有無 | 書き込み性能 | ストレージ削減 |
|------|----------|----------|--------------|----------------|
| Set | 20バイト | なし | 1,240 req/sec | 0% |
| Set | 1KB | あり | 1,224 req/sec | ~24% |
| BatchSet | 20バイト | あり | 151,067 items/sec | ~64% |

圧縮閾値(512バイト)により、単一の小さなデータでは圧縮オーバーヘッドを回避します。バッチ操作では複数エントリがまとめて圧縮されるため、64%もの大幅なストレージ削減を実現しています。

### 改善率 (パイプラインWAL → SkipList + BinarySearch)

| 項目 | 変化 |
|------|------|
| Set Throughput | +7.2% |
| Get Throughput | +9.1% |
| Set Latency | -5.9% |
| Get Latency | -7.9% |

## 考察

1. **読み取り性能**: LSM-tree が Memory エンジンを上回りました。これは SkipList のロックフリーアクセスにより、読み取り時のロック競合が完全に解消されたためです。

2. **書き込み性能**: SkipList により並行書き込みの競合が減少し、約7%の改善が見られました。ただし、WAL の `sync_all()` がボトルネックであるため、劇的な改善には至っていません。

3. **永続性と性能のトレードオフ**:
    | エンジン | 永続性 | 書き込み性能 | 読み取り性能 | 並行性 |
    | :--- | :--- | :--- | :--- | :--- |
    | Memory | なし | 最高 | 高 | 高 |
    | Log | 完全 (逐次) | 最低 | 高 | 低 |
    | LSM-tree | 完全 (グループ) | 中間 | **最高** | **最高** |

## 結論

SkipList MemTable とブロック内バイナリサーチの導入により、LSM-tree エンジンは永続性を維持したまま、読み取り性能でインメモリエンジンを超える結果を達成しました。並行ワークロードにおいて最も優れた選択肢となっています。
